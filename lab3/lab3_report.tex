\documentclass[12pt]{article}

\usepackage{fullpage}
\usepackage{multicol,multirow}
\usepackage{tabularx}
\usepackage{ulem}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{amsmath}
\usepackage{amssymb}

\usepackage{libertine}
\renewcommand{\ttdefault}{cmtt}

\usepackage{titlesec}

\titleformat{\section}
  {\normalfont\Large\bfseries}{\thesection.}{0.3em}{}

\titleformat{\subsection}
  {\normalfont\large\bfseries}{\thesubsection.}{0.3em}{}

\titlespacing{\section}{0pt}{*2}{*2}
\titlespacing{\subsection}{0pt}{*1}{*1}
\titlespacing{\subsubsection}{0pt}{*0}{*0}
\usepackage{listings}
\lstloadlanguages{Lisp}
\lstset{extendedchars=false,
	breaklines=true,
	breakatwhitespace=true,
	keepspaces = true,
	tabsize=2
}

\begin{document}

\section*{Отчет по лабораторной работе №\,3 \\
по курсу \guillemotleft  Функциональное программирование\guillemotright}
\begin{flushright}
Студент группы 8О-307 МАИ \textit{Бирюков Виктор}, \textnumero 2 по списку \\
\makebox[7cm]{Контакты: {\tt vikvladbir@mail.ru} \hfill} \\
\makebox[7cm]{Работа выполнена: 24.04.2022 \hfill} \\
\ \\
Преподаватель: Иванов Дмитрий Анатольевич, доц. каф. 806 \\
\makebox[7cm]{Отчет сдан: \hfill} \\
\makebox[7cm]{Итоговая оценка: \hfill} \\
\makebox[7cm]{Подпись преподавателя: \hfill} \\

\end{flushright}

\section{Тема работы}
Последовательности, массивы и управляющие конструкции Коммон Лисп.

\section{Цель работы}
Научиться создавать векторы и массивы для представления матриц, освоить общие функции работы с последовательностями, инструкции цикла и нелокального выхода.

\section{Задание (вариант №3.45)}
Запрограммировать на языке Коммон Лисп функцию, принимающую в качестве единственного аргумента целое число $n$ - порядок матрицы. Функция должна создавать и возвращать двумерный массив, представляющий целочисленную квадратную матрицу порядка $n$, элементами которой являются числа $1, 2, ... n^2$, расположенные по схеме, показанной на рисунке.

\begin{lstlisting}
(defun matrix-1l-2l (n)
  ...)

(matrix-1l-2l 4) =>
#2A((1  3  4 10)
    (2  5  9 11)
    (6  8 12 15)
    (7 13 14 16))
\end{lstlisting}

\section{Оборудование студента}
Процессор AMD Ryzen 7 3700U\,@\,2.3GHz, память: 20Gb, разрядность системы: 64.

\section{Программное обеспечение}
ОС Windows 10, компилятор SBCL 2.2.2, текстовый редактор Sublime Text 4.

\section{Идея, метод, алгоритм}
Обход матрицы в таком порядке состоит из последовательных обходов ее побочных диагоналей. При этом направление обхода диагоналей чередуется. Элементы побочных диагоналей обладают следующим свойством --- их сумма индексов постоянна и, при нуль-индексации элементов и диагоналей, равна номеру диагонали. Таким образом все элементы побочной диагонали можно однозначно определить, зная номер диагонали и один из индексов самого нижнего или самого верхнего ее элемента.

Функция {\tt fill-side-diag} осуществляет заполнение побочной диагонали с номером m, номером строки крайнего элемента i и в заданном направлении. Диагональ заполняется числами, начиная с idx. Число, следующее за последним в диагонали, возвращается как результат функции.
Функция {\tt fill-matrix} заполняет всю матрицу. Номер строки первого элемента -- 0, направление обхода -- вниз. После заполнения побочной диагонали, номер строки сдвигается в ее конец. Затем происходит перемещение к новой диагонали, при этом необходимо перейти на следующую строку, если мы находимся в первом или последнем столбце. В иных случаях перемещение происходит исключительно за счет изменения m. Направление обхода изменяется на противоположное.

\section{Сценарий выполнения работы}

\section{Распечатка программы и её результаты}

\subsection{Исходный код}
\lstinputlisting[basicstyle=\footnotesize]{./lab3.lisp}

\subsection{Результаты работы}
\begin{lstlisting}
* (print-matrix (matrix-1l-2l 4))

#2A((1 3 4 10)
    (2 5 9 11)
    (6 8 12 15)
    (7 13 14 16))

* (print-matrix (matrix-1l-2l 2))

#2A((1 3)
    (2 4))

* (print-matrix (matrix-1l-2l 5))

#2A((1 3 4 10 11)
    (2 5 9 12 19)
    (6 8 13 18 20)
    (7 14 17 21 24)
    (15 16 22 23 25))

* (print-matrix (matrix-1l-2l 3))

#2A((1 3 4)
    (2 5 8)
    (6 7 9))

* (print-matrix (matrix-1l-2l 8))

#2A((1 3 4 10 11 21 22 36)
    (2 5 9 12 20 23 35 37)
    (6 8 13 19 24 34 38 49)
    (7 14 18 25 33 39 48 50)
    (15 17 26 32 40 47 51 58)
    (16 27 31 41 46 52 57 59)
    (28 30 42 45 53 56 60 63)
    (29 43 44 54 55 61 62 64))
\end{lstlisting}

\section{Дневник отладки}
\begin{tabular}{|c|c|c|c|}
\hline
Дата & Событие & Действие по исправлению & Примечание \\
\hline
\end{tabular}

\section{Замечания автора по существу работы}
Вспомогательные функции описывают линейно-итеративные процессы. Сложность алгоритма --- $O(n^2)$ по времени, $O(n^2)$ по памяти.

\section{Выводы}
В ходе выполнения лабораторной работы я познакомился со структурой данных массив, при помощи которого можно представлять матрицы произвольных размерностей. Непосредственная работа с элементами матрицы делает взаимодействие с ними похожим на взаимодействие в императивных языках.

\end{document}